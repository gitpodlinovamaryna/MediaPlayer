/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.12.v201805221014.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1/MediaPlayer/MediaPlayerStubDefault.hpp>
#include <assert.h>

namespace v1 {
namespace MediaPlayer {

MediaPlayerStubDefault::MediaPlayerStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(MediaPlayer::getInterfaceVersion()) {
}

const CommonAPI::Version& MediaPlayerStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

MediaPlayerStubRemoteEvent* MediaPlayerStubDefault::initStubAdapter(const std::shared_ptr< MediaPlayerStubAdapter> &_adapter) {
    CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

 const std::string& MediaPlayerStubDefault::getTrackNameAttribute() {
     return trackNameAttributeValue_;
 }

 const std::string& MediaPlayerStubDefault::getTrackNameAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
     (void)_client;
     return getTrackNameAttribute();
 }

 void MediaPlayerStubDefault::setTrackNameAttribute(std::string _value) {
     std::shared_ptr<MediaPlayerStubAdapter> stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter,
     MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
     if(stubAdapter) {
         stubAdapter->lockTrackNameAttribute(true);
         const bool valueChanged = (trackNameAttributeValue_ != _value);
         if (valueChanged) {
             trackNameAttributeValue_ = std::move(_value);
             fireTrackNameAttributeChanged(trackNameAttributeValue_);
         }
         stubAdapter->lockTrackNameAttribute(false);
     } else {
         const bool valueChanged = trySetTrackNameAttribute(std::move(_value));
         if (valueChanged) {
             fireTrackNameAttributeChanged(trackNameAttributeValue_);
         }
     }
}

 bool MediaPlayerStubDefault::trySetTrackNameAttribute(std::string _value) {
     if (!validateTrackNameAttributeRequestedValue(_value))
         return false;

     bool valueChanged;
     std::shared_ptr<MediaPlayerStubAdapter> stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
     if(stubAdapter) {
         stubAdapter->lockTrackNameAttribute(true);
         valueChanged = (trackNameAttributeValue_ != _value);
         trackNameAttributeValue_ = std::move(_value);
         stubAdapter->lockTrackNameAttribute(false);
     } else {
         valueChanged = (trackNameAttributeValue_ != _value);
         trackNameAttributeValue_ = std::move(_value);
     }

     return valueChanged;
 }

 bool MediaPlayerStubDefault::validateTrackNameAttributeRequestedValue(const std::string &_value) {
     (void)_value;
     return true;
 }


 const uint16_t& MediaPlayerStubDefault::getTrackTotalLengthAttribute() {
     return trackTotalLengthAttributeValue_;
 }

 const uint16_t& MediaPlayerStubDefault::getTrackTotalLengthAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
     (void)_client;
     return getTrackTotalLengthAttribute();
 }

 void MediaPlayerStubDefault::setTrackTotalLengthAttribute(uint16_t _value) {
     std::shared_ptr<MediaPlayerStubAdapter> stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter,
     MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
     if(stubAdapter) {
         stubAdapter->lockTrackTotalLengthAttribute(true);
         const bool valueChanged = (trackTotalLengthAttributeValue_ != _value);
         if (valueChanged) {
             trackTotalLengthAttributeValue_ = std::move(_value);
             fireTrackTotalLengthAttributeChanged(trackTotalLengthAttributeValue_);
         }
         stubAdapter->lockTrackTotalLengthAttribute(false);
     } else {
         const bool valueChanged = trySetTrackTotalLengthAttribute(std::move(_value));
         if (valueChanged) {
             fireTrackTotalLengthAttributeChanged(trackTotalLengthAttributeValue_);
         }
     }
}

 bool MediaPlayerStubDefault::trySetTrackTotalLengthAttribute(uint16_t _value) {
     if (!validateTrackTotalLengthAttributeRequestedValue(_value))
         return false;

     bool valueChanged;
     std::shared_ptr<MediaPlayerStubAdapter> stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
     if(stubAdapter) {
         stubAdapter->lockTrackTotalLengthAttribute(true);
         valueChanged = (trackTotalLengthAttributeValue_ != _value);
         trackTotalLengthAttributeValue_ = std::move(_value);
         stubAdapter->lockTrackTotalLengthAttribute(false);
     } else {
         valueChanged = (trackTotalLengthAttributeValue_ != _value);
         trackTotalLengthAttributeValue_ = std::move(_value);
     }

     return valueChanged;
 }

 bool MediaPlayerStubDefault::validateTrackTotalLengthAttributeRequestedValue(const uint16_t &_value) {
     (void)_value;
     return true;
 }


 const uint16_t& MediaPlayerStubDefault::getPlayPositionAttribute() {
     return playPositionAttributeValue_;
 }

 const uint16_t& MediaPlayerStubDefault::getPlayPositionAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
     (void)_client;
     return getPlayPositionAttribute();
 }

 void MediaPlayerStubDefault::setPlayPositionAttribute(uint16_t _value) {
     std::shared_ptr<MediaPlayerStubAdapter> stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter,
     MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
     if(stubAdapter) {
         stubAdapter->lockPlayPositionAttribute(true);
         const bool valueChanged = (playPositionAttributeValue_ != _value);
         if (valueChanged) {
             playPositionAttributeValue_ = std::move(_value);
             firePlayPositionAttributeChanged(playPositionAttributeValue_);
         }
         stubAdapter->lockPlayPositionAttribute(false);
     } else {
         const bool valueChanged = trySetPlayPositionAttribute(std::move(_value));
         if (valueChanged) {
             firePlayPositionAttributeChanged(playPositionAttributeValue_);
         }
     }
}

 bool MediaPlayerStubDefault::trySetPlayPositionAttribute(uint16_t _value) {
     if (!validatePlayPositionAttributeRequestedValue(_value))
         return false;

     bool valueChanged;
     std::shared_ptr<MediaPlayerStubAdapter> stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
     if(stubAdapter) {
         stubAdapter->lockPlayPositionAttribute(true);
         valueChanged = (playPositionAttributeValue_ != _value);
         playPositionAttributeValue_ = std::move(_value);
         stubAdapter->lockPlayPositionAttribute(false);
     } else {
         valueChanged = (playPositionAttributeValue_ != _value);
         playPositionAttributeValue_ = std::move(_value);
     }

     return valueChanged;
 }

 bool MediaPlayerStubDefault::validatePlayPositionAttributeRequestedValue(const uint16_t &_value) {
     (void)_value;
     return true;
 }

 void MediaPlayerStubDefault::setPlayPositionAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, uint16_t _value) {
     (void)_client;
     setPlayPositionAttribute(_value);
 }

 void MediaPlayerStubDefault::onRemotePlayPositionAttributeChanged() {
     // No operation in default
 }

 void MediaPlayerStubDefault::RemoteEventHandler::onRemotePlayPositionAttributeChanged() {
     assert(defaultStub_ !=NULL);
     defaultStub_->onRemotePlayPositionAttributeChanged();
 }

 bool MediaPlayerStubDefault::RemoteEventHandler::onRemoteSetPlayPositionAttribute(uint16_t _value) {
     assert(defaultStub_ !=NULL);
     return defaultStub_->trySetPlayPositionAttribute(std::move(_value));
 }

 bool MediaPlayerStubDefault::RemoteEventHandler::onRemoteSetPlayPositionAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, uint16_t _value) {
     (void)_client;
     return onRemoteSetPlayPositionAttribute(_value);
 }

 const ::v1::MediaPlayer::MediaPlayerTypes::CurrentState& MediaPlayerStubDefault::getCurrentStateAttribute() {
     return currentStateAttributeValue_;
 }

 const ::v1::MediaPlayer::MediaPlayerTypes::CurrentState& MediaPlayerStubDefault::getCurrentStateAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
     (void)_client;
     return getCurrentStateAttribute();
 }

 void MediaPlayerStubDefault::setCurrentStateAttribute(::v1::MediaPlayer::MediaPlayerTypes::CurrentState _value) {
     std::shared_ptr<MediaPlayerStubAdapter> stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter,
     MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
     if(stubAdapter) {
         stubAdapter->lockCurrentStateAttribute(true);
         const bool valueChanged = (currentStateAttributeValue_ != _value);
         if (valueChanged) {
             currentStateAttributeValue_ = std::move(_value);
             fireCurrentStateAttributeChanged(currentStateAttributeValue_);
         }
         stubAdapter->lockCurrentStateAttribute(false);
     } else {
         const bool valueChanged = trySetCurrentStateAttribute(std::move(_value));
         if (valueChanged) {
             fireCurrentStateAttributeChanged(currentStateAttributeValue_);
         }
     }
}

 bool MediaPlayerStubDefault::trySetCurrentStateAttribute(::v1::MediaPlayer::MediaPlayerTypes::CurrentState _value) {
     if (!validateCurrentStateAttributeRequestedValue(_value))
         return false;

     bool valueChanged;
     std::shared_ptr<MediaPlayerStubAdapter> stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
     if(stubAdapter) {
         stubAdapter->lockCurrentStateAttribute(true);
         valueChanged = (currentStateAttributeValue_ != _value);
         currentStateAttributeValue_ = std::move(_value);
         stubAdapter->lockCurrentStateAttribute(false);
     } else {
         valueChanged = (currentStateAttributeValue_ != _value);
         currentStateAttributeValue_ = std::move(_value);
     }

     return valueChanged;
 }

 bool MediaPlayerStubDefault::validateCurrentStateAttributeRequestedValue(const ::v1::MediaPlayer::MediaPlayerTypes::CurrentState &_value) {
     (void)_value;
     return _value.validate();
 }



void MediaPlayerStubDefault::play(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
}

void MediaPlayerStubDefault::pause(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
}

void MediaPlayerStubDefault::next(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
}

void MediaPlayerStubDefault::previous(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
}




MediaPlayerStubDefault::RemoteEventHandler::RemoteEventHandler(MediaPlayerStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace MediaPlayer
} // namespace v1
